<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Random_generator (random-generator.Random_generator)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">random-generator</a> &#x00BB; Random_generator</nav><h1>Module <code>Random_generator</code></h1><h2 id="random_generator-is-a-combinator-library-to-generate-random-values."><a href="#random_generator-is-a-combinator-library-to-generate-random-values." class="anchor"></a>Random_generator is a combinator library to generate random values.</h2><nav class="toc"><ul><li><a href="#value-generators-and-combinators">Value generators and combinators</a></li><li><a href="#'a-gen-is-a-functor"><code>'a gen</code> is a functor</a></li><li><a href="#'a-gen-is-applicative"><code>'a gen</code> is applicative</a></li><li><a href="#'a-gen-is-a-monad"><code>'a gen</code> is a monad</a></li><li><a href="#parametrized-fixpoint">parametrized fixpoint</a></li><li><a href="#backtracking-generator">backtracking generator</a></li><li><a href="#fueled-generators">fueled generators</a><ul><li><a href="#convenience-functions-for-fueled-generators">convenience functions for fueled generators</a></li></ul></li></ul></nav></header><dl><dt class="spec type" id="type-random_state"><a href="#type-random_state" class="anchor"></a><code><span class="keyword">type</span> random_state</code><code> = Stdlib.Random.State.t</code></dt><dd><p>Random.State.t is the type of the state of the standard library Random module.</p><p>Use <code>Random.get_state ()</code> to get the current (global) state of the Random module, or <code>Random.State.make : int array -&gt; Random.State.tt</code> or <code>Random.State.make_self_init () : unit -&gt; Random.State.t</code> to generate fresh, independent state.</p></dd></dl><dl><dt class="spec type" id="type-gen"><a href="#type-gen" class="anchor"></a><code><span class="keyword">type</span> <span>'a gen</span></code><code> = <a href="index.html#type-random_state">random_state</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt></dl><dl><dt class="spec value" id="val-run"><a href="#val-run" class="anchor"></a><code><span class="keyword">val</span> run : <span><span class="type-var">'a</span> <a href="index.html#type-gen">gen</a></span> <span>&#45;&gt;</span> <a href="index.html#type-random_state">random_state</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt></dl><section><header><h3 id="value-generators-and-combinators"><a href="#value-generators-and-combinators" class="anchor"></a>Value generators and combinators</h3></header><dl><dt class="spec value" id="val-make_char"><a href="#val-make_char" class="anchor"></a><code><span class="keyword">val</span> make_char : char <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>char <a href="index.html#type-gen">gen</a></span></code></dt><dt class="spec value" id="val-lowercase"><a href="#val-lowercase" class="anchor"></a><code><span class="keyword">val</span> lowercase : <span>char <a href="index.html#type-gen">gen</a></span></code></dt><dt class="spec value" id="val-uppercase"><a href="#val-uppercase" class="anchor"></a><code><span class="keyword">val</span> uppercase : <span>char <a href="index.html#type-gen">gen</a></span></code></dt><dt class="spec value" id="val-digit"><a href="#val-digit" class="anchor"></a><code><span class="keyword">val</span> digit : <span>char <a href="index.html#type-gen">gen</a></span></code></dt><dt class="spec value" id="val-unit"><a href="#val-unit" class="anchor"></a><code><span class="keyword">val</span> unit : <span>unit <a href="index.html#type-gen">gen</a></span></code></dt><dd><p>base combinators names are adapted from Kaputt.Generator</p></dd></dl><dl><dt class="spec value" id="val-prod"><a href="#val-prod" class="anchor"></a><code><span class="keyword">val</span> prod : <span><span class="type-var">'a</span> <a href="index.html#type-gen">gen</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-gen">gen</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="index.html#type-gen">gen</a></span></code></dt><dt class="spec value" id="val-make_int"><a href="#val-make_int" class="anchor"></a><code><span class="keyword">val</span> make_int : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>int <a href="index.html#type-gen">gen</a></span></code></dt><dt class="spec value" id="val-make_nativeint"><a href="#val-make_nativeint" class="anchor"></a><code><span class="keyword">val</span> make_nativeint : nativeint <span>&#45;&gt;</span> nativeint <span>&#45;&gt;</span> <span>nativeint <a href="index.html#type-gen">gen</a></span></code></dt><dt class="spec value" id="val-make_int32"><a href="#val-make_int32" class="anchor"></a><code><span class="keyword">val</span> make_int32 : int32 <span>&#45;&gt;</span> int32 <span>&#45;&gt;</span> <span>int32 <a href="index.html#type-gen">gen</a></span></code></dt><dt class="spec value" id="val-make_int64"><a href="#val-make_int64" class="anchor"></a><code><span class="keyword">val</span> make_int64 : int64 <span>&#45;&gt;</span> int64 <span>&#45;&gt;</span> <span>int64 <a href="index.html#type-gen">gen</a></span></code></dt><dt class="spec value" id="val-make_float"><a href="#val-make_float" class="anchor"></a><code><span class="keyword">val</span> make_float : float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <span>float <a href="index.html#type-gen">gen</a></span></code></dt><dt class="spec value" id="val-string"><a href="#val-string" class="anchor"></a><code><span class="keyword">val</span> string : <span>int <a href="index.html#type-gen">gen</a></span> <span>&#45;&gt;</span> <span>char <a href="index.html#type-gen">gen</a></span> <span>&#45;&gt;</span> <span>string <a href="index.html#type-gen">gen</a></span></code></dt><dt class="spec value" id="val-bool"><a href="#val-bool" class="anchor"></a><code><span class="keyword">val</span> bool : <span>bool <a href="index.html#type-gen">gen</a></span></code></dt><dt class="spec value" id="val-bits"><a href="#val-bits" class="anchor"></a><code><span class="keyword">val</span> bits : <span>int <a href="index.html#type-gen">gen</a></span></code></dt><dt class="spec value" id="val-split_int"><a href="#val-split_int" class="anchor"></a><code><span class="keyword">val</span> split_int : int <span>&#45;&gt;</span> <span><span>(int * int)</span> <a href="index.html#type-gen">gen</a></span></code></dt><dd><p><code>split_int n</code> returns two integers <code>(i,k)</code> each in the interval <code>[0;n]</code> such that <code>i + k = n</code></p></dd></dl><aside><p>list combinators</p></aside><dl><dt class="spec type" id="type-nonempty_list"><a href="#type-nonempty_list" class="anchor"></a><code><span class="keyword">type</span> <span>'a nonempty_list</span></code><code> = <span><span class="type-var">'a</span> list</span></code></dt><dd><p>list combinators being of the form &quot;pick an element such that&quot;, and random generators being total (they cannot fail), we will often require input lists to be non-empty. For convenience reasons, we won't statically enforce this, only use <code>nonempty_list</code> as a reminder of the implicit invariant.</p></dd></dl><dl><dt class="spec value" id="val-select"><a href="#val-select" class="anchor"></a><code><span class="keyword">val</span> select : <span><span class="type-var">'a</span> <a href="index.html#type-nonempty_list">nonempty_list</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-gen">gen</a></span></code></dt><dt class="spec value" id="val-choose"><a href="#val-choose" class="anchor"></a><code><span class="keyword">val</span> choose : <span><span><span class="type-var">'a</span> <a href="index.html#type-gen">gen</a></span> <a href="index.html#type-nonempty_list">nonempty_list</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-gen">gen</a></span></code></dt><dt class="spec value" id="val-shuffle"><a href="#val-shuffle" class="anchor"></a><code><span class="keyword">val</span> shuffle : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> <a href="index.html#type-gen">gen</a></span></code></dt><dd><p>returns a (uniform) permutation of the list</p></dd></dl></section><section><header><h3 id="'a-gen-is-a-functor"><a href="#'a-gen-is-a-functor" class="anchor"></a><code>'a gen</code> is a functor</h3></header><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-gen">gen</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-gen">gen</a></span></code></dt><dt class="spec value" id="val-map'"><a href="#val-map'" class="anchor"></a><code><span class="keyword">val</span> map' : <span><span class="type-var">'a</span> <a href="index.html#type-gen">gen</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-gen">gen</a></span></code></dt></dl><aside><p>The functor's <code>map</code> is very useful to post-process the result of a random generator.</p><pre><code class="ml">let hexa_digit =
    map' (make_int 0 16) (fun i -&gt; &quot;0123456789ABCDEF&quot;.[i])</code></pre><p>As an API convention, I use quotes to signal a version of the combinator with the arguments swapped so that the generator value appears first. This can be useful when you think of your code in terms of &quot;first generate a <code>foo</code>, and then ...&quot; rather than &quot;apply this simple transformation on ...&quot;.</p></aside></section><section><header><h3 id="'a-gen-is-applicative"><a href="#'a-gen-is-applicative" class="anchor"></a><code>'a gen</code> is applicative</h3></header><dl><dt class="spec value" id="val-app"><a href="#val-app" class="anchor"></a><code><span class="keyword">val</span> app : <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <a href="index.html#type-gen">gen</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-gen">gen</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-gen">gen</a></span></code></dt><dt class="spec value" id="val-app'"><a href="#val-app'" class="anchor"></a><code><span class="keyword">val</span> app' : <span><span class="type-var">'a</span> <a href="index.html#type-gen">gen</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <a href="index.html#type-gen">gen</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-gen">gen</a></span></code></dt><dt class="spec value" id="val-pure"><a href="#val-pure" class="anchor"></a><code><span class="keyword">val</span> pure : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-gen">gen</a></span></code></dt></dl><aside><p>Applicative combinators are useful to lift a function applied to pure arguments into a function applied to generators. You would naturally write <code>Array.make n v</code> to initialize an array. If the length and the initial values are instead randomly generated (<code>n : int gen</code> and <code>v : 'a gen</code>), then you can mechanically write <code>app (app (pure Array.make) f) n</code>. In practice you should define your preferred infix operators for <code>app</code> (I use <code>($$)</code>) to write <code>pure Array.make $$ f $$ n</code>.</p></aside></section><section><header><h3 id="'a-gen-is-a-monad"><a href="#'a-gen-is-a-monad" class="anchor"></a><code>'a gen</code> is a monad</h3></header><dl><dt class="spec value" id="val-return"><a href="#val-return" class="anchor"></a><code><span class="keyword">val</span> return : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-gen">gen</a></span></code></dt><dd><p>synonym of <code>pure</code></p></dd></dl><dl><dt class="spec value" id="val-bind"><a href="#val-bind" class="anchor"></a><code><span class="keyword">val</span> bind : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-gen">gen</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-gen">gen</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-gen">gen</a></span></code></dt><dt class="spec value" id="val-bind'"><a href="#val-bind'" class="anchor"></a><code><span class="keyword">val</span> bind' : <span><span class="type-var">'a</span> <a href="index.html#type-gen">gen</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-gen">gen</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-gen">gen</a></span></code></dt><dt class="spec value" id="val-join"><a href="#val-join" class="anchor"></a><code><span class="keyword">val</span> join : <span><span><span class="type-var">'a</span> <a href="index.html#type-gen">gen</a></span> <a href="index.html#type-gen">gen</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-gen">gen</a></span></code></dt></dl><aside><p>Monad combinators are useful when you need an intermediate random result to return not a random value (<code>map</code> is enough for this) but a random <i>generator</i> -- the generator is itself picked randomly. Applicative is often enough in practice, as you can usually statically decide the structure of your random generator, and build it by applying pure functions to random inputs.</p><p>For an example of <code>bind</code>, consider you want to generate any positive integer, but you prefer to generate small numbers more often (they're easier to work with). One idea is to first draw a boolean at random, then decide what kind of number to generate based on it.</p><pre><code class="ml">let my_gen =
bind' bool (function
| true -&gt; make_int 0 10
| false -&gt; make_int 0 max_int)</code></pre><p>Remark: the kind of logic used in this example (picking a generator among a finite set) is encapsulated in the <a href="index.html#val-choose"><code>choose</code></a> function.</p><pre><code class="ml">let my_gen = choose [make_int 0 10; make_int 0 max_int]</code></pre></aside></section><section><header><h3 id="parametrized-fixpoint"><a href="#parametrized-fixpoint" class="anchor"></a>parametrized fixpoint</h3></header><dl><dt class="spec value" id="val-fix"><a href="#val-fix" class="anchor"></a><code><span class="keyword">val</span> fix : <span>(<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-gen">gen</a></span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-gen">gen</a></span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-gen">gen</a></span></code></dt></dl><aside><p>Parametrized fixpoint is more expressive than non-parametrized fixpoint <code>('b gen -&gt; 'b gen) -&gt; 'b gen</code>, as it encodes recursive calls with varying arguments. Consider a factorial function defined by the following pseudo-code:</p><pre><code class="ml">let rec fact = function
| 0 -&gt; 1 or -1 (at random)
| n -&gt; n * fact (n - 1)</code></pre><p>Encoding it as a fixpoint is direct, the trick is to name the weird function argument 'fact' as well, and use it in place of recursive calls:</p><pre><code class="ml">let fact = fix (fun fact -&gt; function
  | 0 -&gt; select [1; -1]
  | n -&gt; map (( * ) n) (fact (n - 1)))</code></pre></aside></section><section><header><h3 id="backtracking-generator"><a href="#backtracking-generator" class="anchor"></a>backtracking generator</h3></header><dl><dt class="spec type" id="type-backtrack_gen"><a href="#type-backtrack_gen" class="anchor"></a><code><span class="keyword">type</span> <span>'a backtrack_gen</span></code><code> = <span><span><span class="type-var">'a</span> option</span> <a href="index.html#type-gen">gen</a></span></code></dt><dd><p>Represents generator that may fail.</p></dd></dl><aside><p>It is quite common when doing random testing to ask for an element randomly generated by <code>gen</code>, but only one that satisfies some predicate <code>p</code>. This can be expressed simply as <code>succeed gen |&gt;
    guard p |&gt; backtrack</code>.</p></aside><dl><dt class="spec value" id="val-succeed"><a href="#val-succeed" class="anchor"></a><code><span class="keyword">val</span> succeed : <span><span class="type-var">'a</span> <a href="index.html#type-gen">gen</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-backtrack_gen">backtrack_gen</a></span></code></dt><dt class="spec value" id="val-guard"><a href="#val-guard" class="anchor"></a><code><span class="keyword">val</span> guard : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-backtrack_gen">backtrack_gen</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-backtrack_gen">backtrack_gen</a></span></code></dt><dt class="spec value" id="val-cond"><a href="#val-cond" class="anchor"></a><code><span class="keyword">val</span> cond : bool <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-backtrack_gen">backtrack_gen</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-backtrack_gen">backtrack_gen</a></span></code></dt><dd><p><code>cond b gen</code> should be preferred to <code>guard (fun _ -&gt; b) gen</code> for performance reasons, as the generator is not requested any output in the <code>false</code> case.</p></dd></dl><dl><dt class="spec value" id="val-backtrack"><a href="#val-backtrack" class="anchor"></a><code><span class="keyword">val</span> backtrack : <span><span class="type-var">'a</span> <a href="index.html#type-backtrack_gen">backtrack_gen</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-gen">gen</a></span></code></dt><dd><p><code>backtrack gen</code> will loop until the generator returns a successful value <code>Some v</code>. This may not terminate, and more generally can be a performance concern. You should test validity as locally as possible.</p></dd></dl></section><section><header><h3 id="fueled-generators"><a href="#fueled-generators" class="anchor"></a>fueled generators</h3></header><dl><dt class="spec type" id="type-fueled"><a href="#type-fueled" class="anchor"></a><code><span class="keyword">type</span> <span>'a fueled</span></code><code> = <span><span>(int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span>)</span> <a href="index.html#type-gen">gen</a></span></code></dt></dl><aside><p>Fueled generators are domain-specific generators aimed at producing &quot;good-looking&quot; values that have a size and are built from subcomponents -- in particular values of algebraic types.</p><p>Consider a type of binary trees:</p><pre><code class="ml">type 'a tree = Leaf of 'a | Node of 'a tree * 'a tree
let _Leaf v = Leaf v
let _Node t1 t2 = Node (t1, t2)</code></pre><p>You can generate trees by using <code>fix</code>, but how would you control the size of the produced tree? You could flip a coin each time to decide whether to produce a <code>Leaf</code> or a <code>Node</code>, and then hope that as probability to get to depth N decreases exponentially, your trees will not be too large in practice.</p><p>The problem with most of those obvious methods is that you will get &quot;bad-looking&quot; terms, with highly skewed branches, either much smaller or much larger than you expected, etc. This is probably fine to exercize your code, but becomes problematic when you find a counter-example of the property you're testing, and cannot display and look at it without getting a headache.</p><p>Fuel is a generic technique to generate &quot;good-looking&quot; terms. The idea is that instead of trying to limit the height of tree branches, you randomly pick in advance the size (number of nodes) of the tree you will generate (with the distribution of your choice), then thread an &quot;amount of fuel left&quot; to each recursive subcall representing their part of the tree should have; when generating several branches, you want the fuel to be split randomly between each.</p><p>If you want to generate two branches of the tree, you may think of first passing the whole fuel you have to the generator of the left branch, consider it will not consume everything, and pass the rest to the right branch. This is not what this library does: we decide in advance which amount of fuel each branch should consume (such that the sum is the total amount available, usually minus one to account for the node's cost itself), and then force each branch to build a term <i>exactly of this size</i>.</p><p>A <i>fueled generator</i> <code>'a fueled</code> is therefore a generator that randomly produces not an <code>'a</code>, but a <code>int -&gt; 'a option</code> value: a function that, given some amount of fuel, will produce an <code>'a</code> consuming exactly this amount of fuel, or fail (if there is no term of the requested size) and return <code>None</code>.</p></aside><dl><dt class="spec module" id="module-Fuel"><a href="#module-Fuel" class="anchor"></a><code><span class="keyword">module</span> <a href="Fuel/index.html">Fuel</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The <code>Fuel</code> submodule provides the basic operations on fueled generators.</p></dd></dl><aside><p>The library provides you with the basic constructions to build fueled generators; in particular, you have to apply the <code>tick</code> function yourself at places that you think should consume one unit of fuel, and can provide your own splitting function to say how to divide fuel between subbranches (if you have a simple situation with only two branches, you can use <a href="index.html#val-split_int"><code>split_int</code></a>).</p><p>We also provide some convenience functions outside this module, <a href="index.html#val-nullary"><code>nullary</code></a>, <a href="index.html#val-unary"><code>unary</code></a> and <a href="index.html#val-binary"><code>binary</code></a>, that have a pre-build tick+split logic that will suit most practical use cases for generating inductive types with constructors having zero, one or two recursive occurences.</p><p>Remark: I have no idea what the distribution of terms generated used this technique is, and whether it is &quot;uniform&quot; -- probably not. I only found it very useful in practice.</p><p>Here is a fueled generator for <code>unit tree</code>:</p><pre><code class="ml">let tree : unit tree fueled =
  Fuel.fix (fun tree () -&gt;
    Fuel.choose [
      nullary (Leaf ());
      binary (tree ()) (tree ()) _Node;
    ]) ()</code></pre><p>Now consider producing a <code>bool tree</code>, with each leaf boolean picked at random. An important thing to understand is that Fuel's duty and scope is to pick a random <i>shape</i> for your data structure, not help you select the values of the non-recursive part of the program (randomly or not). The right way to do that is to actually build a <code>bool tree gen fueled</code>, that is a fueled generator of <i>random boolean trees</i> of a given shape (decided by the fuel engine); so we have one level of randomness for the shape, one for the leaf values.</p><pre><code class="ml">let random_tree : bool tree gen fueled =
  let ($$) = app in
  Fuel.fix (fun random_tree () -&gt;
    Fuel.choose [
      nullary (pure _Leaf $$ bool);
      binary (random_tree ()) (random_tree ())
        (fun t1 t2 -&gt; pure _Node $$ t1 $$ t2);
    ]) ()

let tree (size : int gen) : bool tree gen =
  app random_tree size |&gt; backtrack |&gt; join</code></pre></aside><section><header><h4 id="convenience-functions-for-fueled-generators"><a href="#convenience-functions-for-fueled-generators" class="anchor"></a>convenience functions for fueled generators</h4></header><dl><dt class="spec value" id="val-nullary"><a href="#val-nullary" class="anchor"></a><code><span class="keyword">val</span> nullary : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-fueled">fueled</a></span></code></dt><dd><p>zero</p></dd></dl><dl><dt class="spec value" id="val-unary"><a href="#val-unary" class="anchor"></a><code><span class="keyword">val</span> unary : <span><span class="type-var">'a</span> <a href="index.html#type-fueled">fueled</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-fueled">fueled</a></span></code></dt><dd><p>will do a tick</p></dd></dl><dl><dt class="spec value" id="val-binary"><a href="#val-binary" class="anchor"></a><code><span class="keyword">val</span> binary : <span><span class="type-var">'a</span> <a href="index.html#type-fueled">fueled</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-fueled">fueled</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> <a href="index.html#type-fueled">fueled</a></span></code></dt><dd><p>will do a tick and use split_int</p></dd></dl></section></section></div></body></html>