<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Random_generator" rel="Chapter" href="Random_generator.html"><link title="Value generators and combinators" rel="Section" href="#2_Valuegeneratorsandcombinators">
<link title="'a gen is a functor" rel="Section" href="#2_agenisafunctor">
<link title="'a gen is applicative" rel="Section" href="#2_agenisapplicative">
<link title="'a gen is a monad" rel="Section" href="#2_agenisamonad">
<link title="parametrized fixpoint" rel="Section" href="#2_parametrizedfixpoint">
<link title="backtracking generator" rel="Section" href="#2_backtrackinggenerator">
<link title="fueled generators" rel="Section" href="#2_fueledgenerators">
<link title="convenience functions for fueled generators" rel="Subsection" href="#3_conveniencefunctionsforfueledgenerators">
<title>Random_generator</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;</div>
<h1>Module <a href="type_Random_generator.html">Random_generator</a></h1>

<pre><span id="MODULERandom_generator"><span class="keyword">module</span> Random_generator</span>: <code class="code">sig</code> <a href="Random_generator.html">..</a> <code class="code">end</code></pre><div class="info module top">
<div class="info-desc">
<h2 id="1_Randomgeneratorisacombinatorlibrarytogeneraterandomvalues">Random_generator is a combinator library to generate random values. </h2></div>
</div>
<hr width="100%">

<pre><span id="TYPErandom_state"><span class="keyword">type</span> <code class="type"></code>random_state</span> = <code class="type">Stdlib.Random.State.t</code> </pre>
<div class="info ">
<div class="info-desc">
<p>Random.State.t is the type of the state of the standard library
    Random module.</p>

<p>Use <code class="code">Random.get_state ()</code> to get the current (global) state of the
    Random module, or <code class="code">Random.State.make : int array -&gt; Random.State.tt</code>
    or <code class="code">Random.State.make_self_init () : unit -&gt; Random.State.t</code> to generate
    fresh, independent state.</p>
</div>
</div>


<pre><span id="TYPEgen"><span class="keyword">type</span> <code class="type">'a</code> gen</span> = <code class="type"><a href="Random_generator.html#TYPErandom_state">random_state</a> -> 'a</code> </pre>


<pre><span id="VALrun"><span class="keyword">val</span> run</span> : <code class="type">'a <a href="Random_generator.html#TYPEgen">gen</a> -> <a href="Random_generator.html#TYPErandom_state">random_state</a> -> 'a</code></pre><h3 id="2_Valuegeneratorsandcombinators">Value generators and combinators</h3>
<pre><span id="VALmake_char"><span class="keyword">val</span> make_char</span> : <code class="type">char -> int -> char <a href="Random_generator.html#TYPEgen">gen</a></code></pre>
<pre><span id="VALlowercase"><span class="keyword">val</span> lowercase</span> : <code class="type">char <a href="Random_generator.html#TYPEgen">gen</a></code></pre>
<pre><span id="VALuppercase"><span class="keyword">val</span> uppercase</span> : <code class="type">char <a href="Random_generator.html#TYPEgen">gen</a></code></pre>
<pre><span id="VALunit"><span class="keyword">val</span> unit</span> : <code class="type">unit <a href="Random_generator.html#TYPEgen">gen</a></code></pre><div class="info ">
<div class="info-desc">
<p>base combinators names are adapted from Kaputt.Generator</p>
</div>
</div>

<pre><span id="VALmake_int"><span class="keyword">val</span> make_int</span> : <code class="type">int -> int -> int <a href="Random_generator.html#TYPEgen">gen</a></code></pre>
<pre><span id="VALmake_nativeint"><span class="keyword">val</span> make_nativeint</span> : <code class="type">nativeint -> nativeint -> nativeint <a href="Random_generator.html#TYPEgen">gen</a></code></pre>
<pre><span id="VALmake_int32"><span class="keyword">val</span> make_int32</span> : <code class="type">int32 -> int32 -> int32 <a href="Random_generator.html#TYPEgen">gen</a></code></pre>
<pre><span id="VALmake_int64"><span class="keyword">val</span> make_int64</span> : <code class="type">int64 -> int64 -> int64 <a href="Random_generator.html#TYPEgen">gen</a></code></pre>
<pre><span id="VALmake_float"><span class="keyword">val</span> make_float</span> : <code class="type">float -> float -> float <a href="Random_generator.html#TYPEgen">gen</a></code></pre>
<pre><span id="VALstring"><span class="keyword">val</span> string</span> : <code class="type">int <a href="Random_generator.html#TYPEgen">gen</a> -><br>       char <a href="Random_generator.html#TYPEgen">gen</a> -> string <a href="Random_generator.html#TYPEgen">gen</a></code></pre>
<pre><span id="VALbool"><span class="keyword">val</span> bool</span> : <code class="type">bool <a href="Random_generator.html#TYPEgen">gen</a></code></pre>
<pre><span id="VALbits"><span class="keyword">val</span> bits</span> : <code class="type">int <a href="Random_generator.html#TYPEgen">gen</a></code></pre>
<pre><span id="VALsplit_int"><span class="keyword">val</span> split_int</span> : <code class="type">int -> (int * int) <a href="Random_generator.html#TYPEgen">gen</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">split_int n</code> returns two integers <code class="code">(i,k)</code> each in the interval
    <code class="code">[0;n]</code> such that <code class="code">i + k = n</code></p>
</div>
</div>
<p>list combinators</p>

<pre><span id="TYPEnonempty_list"><span class="keyword">type</span> <code class="type">'a</code> nonempty_list</span> = <code class="type">'a list</code> </pre>
<div class="info ">
<div class="info-desc">
<p>list combinators being of the form "pick an element such that",
    and random generators being total (they cannot fail), we will
    often require input lists to be non-empty. For convenience
    reasons, we won't statically enforce this, only use
    <code class="code">nonempty_list</code> as a reminder of the implicit invariant.</p>
</div>
</div>


<pre><span id="VALselect"><span class="keyword">val</span> select</span> : <code class="type">'a <a href="Random_generator.html#TYPEnonempty_list">nonempty_list</a> -> 'a <a href="Random_generator.html#TYPEgen">gen</a></code></pre>
<pre><span id="VALchoose"><span class="keyword">val</span> choose</span> : <code class="type">'a <a href="Random_generator.html#TYPEgen">gen</a> <a href="Random_generator.html#TYPEnonempty_list">nonempty_list</a> -><br>       'a <a href="Random_generator.html#TYPEgen">gen</a></code></pre>
<pre><span id="VALshuffle"><span class="keyword">val</span> shuffle</span> : <code class="type">'a list -> 'a list <a href="Random_generator.html#TYPEgen">gen</a></code></pre><div class="info ">
<div class="info-desc">
<p>returns a (uniform) permutation of the list</p>
</div>
</div>
<h3 id="2_agenisafunctor"><code class="code">'a gen</code> is a functor</h3>
<pre><span id="VALmap"><span class="keyword">val</span> map</span> : <code class="type">('a -> 'b) -> 'a <a href="Random_generator.html#TYPEgen">gen</a> -> 'b <a href="Random_generator.html#TYPEgen">gen</a></code></pre>
<pre><span id="VALmap'"><span class="keyword">val</span> map'</span> : <code class="type">'a <a href="Random_generator.html#TYPEgen">gen</a> -> ('a -> 'b) -> 'b <a href="Random_generator.html#TYPEgen">gen</a></code></pre><p>The functor's <code class="code">map</code> is very useful to post-process the result of
    a random generator.</p>
<pre class="codepre"><code class="code">    let hexa_digit =
        map' (make_int 0 16) (fun i -&gt; "0123456789ABCDEF".[i])
</code></pre>
<p>As an API convention, I use quotes to signal a version of the
    combinator with the arguments swapped so that the generator value
    appears first. This can be useful when you think of your code in
    terms of "first generate a <code class="code">foo</code>, and then ..." rather than "apply
    this simple transformation on ...".</p>
<h3 id="2_agenisapplicative"><code class="code">'a gen</code> is applicative</h3>
<pre><span id="VALapp"><span class="keyword">val</span> app</span> : <code class="type">('a -> 'b) <a href="Random_generator.html#TYPEgen">gen</a> -><br>       'a <a href="Random_generator.html#TYPEgen">gen</a> -> 'b <a href="Random_generator.html#TYPEgen">gen</a></code></pre>
<pre><span id="VALapp'"><span class="keyword">val</span> app'</span> : <code class="type">'a <a href="Random_generator.html#TYPEgen">gen</a> -><br>       ('a -> 'b) <a href="Random_generator.html#TYPEgen">gen</a> -> 'b <a href="Random_generator.html#TYPEgen">gen</a></code></pre>
<pre><span id="VALpure"><span class="keyword">val</span> pure</span> : <code class="type">'a -> 'a <a href="Random_generator.html#TYPEgen">gen</a></code></pre><p>Applicative combinators are useful to lift a function applied to
    pure arguments into a function applied to generators. You would
    naturally write <code class="code">Array.make n v</code> to initialize an array. If the
    length and the initial values are instead randomly generated
    (<code class="code">n : int gen</code> and <code class="code">v : 'a gen</code>), then you can mechanically write
    <code class="code">app (app (pure Array.make) f) n</code>. In practice you should define
    your preferred infix operators for <code class="code">app</code> (I use <code class="code">($$)</code>)
    to write <code class="code">pure Array.make $$ f $$ n</code>.</p>
<h3 id="2_agenisamonad"><code class="code">'a gen</code> is a monad</h3>
<pre><span id="VALreturn"><span class="keyword">val</span> return</span> : <code class="type">'a -> 'a <a href="Random_generator.html#TYPEgen">gen</a></code></pre><div class="info ">
<div class="info-desc">
<p>synonym of <code class="code">pure</code></p>
</div>
</div>

<pre><span id="VALbind"><span class="keyword">val</span> bind</span> : <code class="type">('a -> 'b <a href="Random_generator.html#TYPEgen">gen</a>) -><br>       'a <a href="Random_generator.html#TYPEgen">gen</a> -> 'b <a href="Random_generator.html#TYPEgen">gen</a></code></pre>
<pre><span id="VALbind'"><span class="keyword">val</span> bind'</span> : <code class="type">'a <a href="Random_generator.html#TYPEgen">gen</a> -><br>       ('a -> 'b <a href="Random_generator.html#TYPEgen">gen</a>) -> 'b <a href="Random_generator.html#TYPEgen">gen</a></code></pre>
<pre><span id="VALjoin"><span class="keyword">val</span> join</span> : <code class="type">'a <a href="Random_generator.html#TYPEgen">gen</a> <a href="Random_generator.html#TYPEgen">gen</a> -> 'a <a href="Random_generator.html#TYPEgen">gen</a></code></pre><p>Monad combinators are useful when you need an intermediate random
    result to return not a random value (<code class="code">map</code> is enough for this) but
    a random <i>generator</i> -- the generator is itself picked
    randomly. Applicative is often enough in practice, as you can
    usually statically decide the structure of your random generator,
    and build it by applying pure functions to random inputs.</p>

<p>For an example of <code class="code">bind</code>, consider you want to generate any
    positive integer, but you prefer to generate small numbers more
    often (they're easier to work with). One idea is to first draw
    a boolean at random, then decide what kind of number to generate
    based on it.</p>
<pre class="codepre"><code class="code">    let my_gen =
    bind' bool (function
    | true -&gt; make_int 0 10
    | false -&gt; make_int 0 max_int)
</code></pre>
<p>Remark: the kind of logic used in this example
    (picking a generator among a finite set) is encapsulated in the
    <a href="Random_generator.html#VALchoose"><code class="code">Random_generator.choose</code></a> function.</p>
<pre class="codepre"><code class="code">    let my_gen = choose [make_int 0 10; make_int 0 max_int]
</code></pre><h3 id="2_parametrizedfixpoint">parametrized fixpoint</h3>
<pre><span id="VALfix"><span class="keyword">val</span> fix</span> : <code class="type">(('a -> 'b <a href="Random_generator.html#TYPEgen">gen</a>) -> 'a -> 'b <a href="Random_generator.html#TYPEgen">gen</a>) -><br>       'a -> 'b <a href="Random_generator.html#TYPEgen">gen</a></code></pre><p>Parametrized fixpoint is more expressive than non-parametrized
    fixpoint <code class="code">('b gen -&gt; 'b gen) -&gt; 'b gen</code>, as it encodes recursive
    calls with varying arguments. Consider a factorial function defined
    by the following pseudo-code:</p>
<pre class="codepre"><code class="code">    let rec fact = function
    | 0 -&gt; 1 or -1 (at random)
    | n -&gt; n * fact (n - 1)
</code></pre><p>Encoding it as a fixpoint is direct, the trick is to name the
    weird function argument 'fact' as well, and use it in place of
    recursive calls:</p>
<pre class="codepre"><code class="code">    let fact = fix (fun fact -&gt; function
      | 0 -&gt; select [1; -1]
      | n -&gt; map (( * ) n) (fact (n - 1)))
</code></pre><h3 id="2_backtrackinggenerator">backtracking generator</h3>
<pre><span id="TYPEbacktrack_gen"><span class="keyword">type</span> <code class="type">'a</code> backtrack_gen</span> = <code class="type">'a option <a href="Random_generator.html#TYPEgen">gen</a></code> </pre>
<div class="info ">
<div class="info-desc">
<p>Represents generator that may fail.</p>
</div>
</div>

<p>It is quite common when doing random testing to ask for an element
    randomly generated by <code class="code">gen</code>, but only one that satisfies some
    predicate <code class="code">p</code>. This can be expressed simply as <code class="code">succeed gen |&gt;
    guard p |&gt; backtrack</code>.</p>

<pre><span id="VALsucceed"><span class="keyword">val</span> succeed</span> : <code class="type">'a <a href="Random_generator.html#TYPEgen">gen</a> -> 'a <a href="Random_generator.html#TYPEbacktrack_gen">backtrack_gen</a></code></pre>
<pre><span id="VALguard"><span class="keyword">val</span> guard</span> : <code class="type">('a -> bool) -><br>       'a <a href="Random_generator.html#TYPEbacktrack_gen">backtrack_gen</a> -> 'a <a href="Random_generator.html#TYPEbacktrack_gen">backtrack_gen</a></code></pre>
<pre><span id="VALcond"><span class="keyword">val</span> cond</span> : <code class="type">bool -><br>       'a <a href="Random_generator.html#TYPEbacktrack_gen">backtrack_gen</a> -> 'a <a href="Random_generator.html#TYPEbacktrack_gen">backtrack_gen</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">cond b gen</code> should be preferred to <code class="code">guard (fun _ -&gt; b) gen</code> for
    performance reasons, as the generator is not requested any output
    in the <code class="code">false</code> case.</p>
</div>
</div>

<pre><span id="VALbacktrack"><span class="keyword">val</span> backtrack</span> : <code class="type">'a <a href="Random_generator.html#TYPEbacktrack_gen">backtrack_gen</a> -> 'a <a href="Random_generator.html#TYPEgen">gen</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">backtrack gen</code> will loop until the generator returns a successful
    value <code class="code">Some v</code>. This may not terminate, and more generally can be
    a performance concern. You should test validity as locally as
    possible.</p>
</div>
</div>
<h3 id="2_fueledgenerators">fueled generators</h3>
<pre><span id="TYPEfueled"><span class="keyword">type</span> <code class="type">'a</code> fueled</span> = <code class="type">(int -> 'a option) <a href="Random_generator.html#TYPEgen">gen</a></code> </pre>

<p>Fueled generators are domain-specific generators aimed at
    producing "good-looking" values that have a size and are built
    from subcomponents -- in particular values of algebraic types.</p>

<p>Consider a type of binary trees:</p>
<pre class="codepre"><code class="code">    type 'a tree = Leaf of 'a | Node of 'a tree * 'a tree
    let _Leaf v = Leaf v
    let _Node t1 t2 = Node (t1, t2)
</code></pre>
<p>You can generate trees by using <code class="code">fix</code>, but how would you control
    the size of the produced tree? You could flip a coin each time to
    decide whether to produce a <code class="code">Leaf</code> or a <code class="code">Node</code>, and then hope that
    as probability to get to depth N decreases exponentially, your
    trees will not be too large in practice.</p>

<p>The problem with most of those obvious methods is that you will
    get "bad-looking" terms, with highly skewed branches, either much
    smaller or much larger than you expected, etc. This is probably
    fine to exercize your code, but becomes problematic when you find
    a counter-example of the property you're testing, and cannot
    display and look at it without getting a headache.</p>

<p>Fuel is a generic technique to generate "good-looking" terms. The
    idea is that instead of trying to limit the height of tree
    branches, you randomly pick in advance the size (number of nodes)
    of the tree you will generate (with the distribution of
    your choice), then thread an "amount of fuel left" to each
    recursive subcall representing their part of the tree should have;
    when generating several branches, you want the fuel to be split
    randomly between each.</p>

<p>If you want to generate two branches of the tree, you may think of
    first passing the whole fuel you have to the generator of the left
    branch, consider it will not consume everything, and pass the rest
    to the right branch. This is not what this library does: we decide
    in advance which amount of fuel each branch should consume
    (such that the sum is the total amount available, usually minus
    one to account for the node's cost itself), and then force each
    branch to build a term <i>exactly of this size</i>.</p>

<p>A <i>fueled generator</i> <code class="code">'a fueled</code> is therefore a generator that
    randomly produces not an <code class="code">'a</code>, but a <code class="code">int -&gt; 'a option</code> value:
    a function that, given some amount of fuel, will produce an <code class="code">'a</code>
    consuming exactly this amount of fuel, or fail (if there is no
    term of the requested size) and return <code class="code">None</code>.</p>

<pre><span id="MODULEFuel"><span class="keyword">module</span> <a href="Random_generator.Fuel.html">Fuel</a></span>: <code class="code">sig</code> <a href="Random_generator.Fuel.html">..</a> <code class="code">end</code></pre><div class="info">
<p>The <code class="code">Fuel</code> submodule provides the basic operations on fueled
    generators.</p>

</div>
<p>The library provides you with the basic constructions to build
    fueled generators; in particular, you have to apply the <code class="code">tick</code>
    function yourself at places that you think should consume one unit
    of fuel, and can provide your own splitting function to say how to
    divide fuel between subbranches (if you have a simple situation
    with only two branches, you can use <a href="Random_generator.html#VALsplit_int"><code class="code">Random_generator.split_int</code></a>).</p>

<p>We also provide some convenience functions outside
    this module, <a href="Random_generator.html#VALnullary"><code class="code">Random_generator.nullary</code></a>, <a href="Random_generator.html#VALunary"><code class="code">Random_generator.unary</code></a> and <a href="Random_generator.html#VALbinary"><code class="code">Random_generator.binary</code></a>, that have
    a pre-build tick+split logic that will suit most practical use
    cases for generating inductive types with constructors having
    zero, one or two recursive occurences.</p>

<p>Remark: I have no idea what the distribution of terms generated
    used this technique is, and whether it is "uniform" -- probably
    not. I only found it very useful in practice.</p>

<p>Here is a fueled generator for <code class="code">unit tree</code>:</p>
<pre class="codepre"><code class="code">    let tree : unit tree fueled =
      Fuel.fix (fun tree () -&gt;
        Fuel.choose [
          nullary (Leaf ());
          binary (tree ()) (tree ()) _Node;
        ]) ()
</code></pre>
<p>Now consider producing a <code class="code">bool tree</code>, with each leaf boolean
    picked at random. An important thing to understand is that Fuel's
    duty and scope is to pick a random <i>shape</i> for your data
    structure, not help you select the values of the non-recursive
    part of the program (randomly or not). The right way to do that is
    to actually build a <code class="code">bool tree gen fueled</code>, that is a fueled
    generator of <i>random boolean trees</i> of a given shape (decided by
    the fuel engine); so we have one level of randomness for the
    shape, one for the leaf values.</p>
<pre class="codepre"><code class="code">    let random_tree : bool tree gen fueled =
      let ($$) = app in
      Fuel.fix (fun random_tree () -&gt;
        Fuel.choose [
          nullary (pure _Leaf $$ bool);
          binary (random_tree ()) (random_tree ())
            (fun t1 t2 -&gt; pure _Node $$ t1 $$ t2);
        ]) ()

    let tree (size : int gen) : bool tree gen =
      app random_tree size |&gt; backtrack |&gt; join
</code></pre><h4 id="3_conveniencefunctionsforfueledgenerators">convenience functions for fueled generators</h4>
<pre><span id="VALnullary"><span class="keyword">val</span> nullary</span> : <code class="type">'a -> 'a <a href="Random_generator.html#TYPEfueled">fueled</a></code></pre><div class="info ">
<div class="info-desc">
<p>zero</p>
</div>
</div>

<pre><span id="VALunary"><span class="keyword">val</span> unary</span> : <code class="type">'a <a href="Random_generator.html#TYPEfueled">fueled</a> -> ('a -> 'b) -> 'b <a href="Random_generator.html#TYPEfueled">fueled</a></code></pre><div class="info ">
<div class="info-desc">
<p>will do a tick</p>
</div>
</div>

<pre><span id="VALbinary"><span class="keyword">val</span> binary</span> : <code class="type">'a <a href="Random_generator.html#TYPEfueled">fueled</a> -><br>       'b <a href="Random_generator.html#TYPEfueled">fueled</a> -> ('a -> 'b -> 'c) -> 'c <a href="Random_generator.html#TYPEfueled">fueled</a></code></pre><div class="info ">
<div class="info-desc">
<p>will do a tick and use split_int</p>
</div>
</div>
</body></html>
